import java.util.regex.Matcher
import java.util.regex.Pattern

apply plugin: 'com.tencent.tinker.patch'
/**
 * TODO: 请按自己的需求修改为适应自己工程的参数
 */
def bakPath = file("${buildDir}/bakApk/")
def baseInfo = "app-base-1.0.0-0510-18-51-58"
def variantName = "release"

/**
 * 引入 AndResGuard的相关配置
 */
project.ext {
    TP_BAKPATH = bakPath
    TP_BASEINFO = baseInfo
    TP_VARIANTNAME = variantName
}
apply from: 'andresguard.gradle'

/**
 * 用于用户在代码中判断tinkerPatch是否被使能
 */
android {
    defaultConfig {
        buildConfigField "boolean", "TINKER_ENABLE", "${buildWithTinker()}"
    }
}

def buildWithTinker() {
    return hasProperty("TINKER_ENABLE") ? TINKER_ENABLE : true
}
/**
 * 一般来说,我们无需对下面的参数做任何的修改
 * 对于各参数的详细介绍请参考:
 * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97
 */
tinkerPatch {
    def pathPrefix = "${bakPath}/${baseInfo}/${variantName}/"
    def name = "${project.name}-${variantName}"
    oldApk = "${pathPrefix}/${name}.apk"
    tinkerEnable = isRelease()
    ignoreWarning = false
    useSign = true
    dex {
        dexMode = "jar"
        pattern = ["classes*.dex"]
        loader = []
    }

    /**
     * Warning, applyMapping will affect the normal android build!
     */
    buildConfig {
        /**
         * optional，default 'null'
         * if we use tinkerPatch to build the patch apk, you'd better to apply the old
         * apk mapping file if minifyEnabled is enable!
         * Warning:
         * you must be careful that it will affect the normal assemble build!
         */
        applyMapping = "${pathPrefix}/${name}-mapping.txt"

        /**
         * optional，default 'null'
         * It is nice to keep the resource id from R.txt file to reduce java changes
         */
//        applyResourceMapping = "${pathPrefix}/${name}-resource_mapping.txt"

        /**
         * necessary，default 'null'
         * because we don't want to check the base apk with md5 in the runtime(it is slow)
         * tinkerId is use to identify the unique base apk when the patch is tried to apply.
         * we can use git rev, svn rev or simply versionCode.
         * we will gen the tinkerId in your manifest automatic
         */
        tinkerId = "base-1.0.0"

        /**
         * if keepDexApply is true, class in which dex refer to the old apk.
         * open this can reduce the dex diff file size.
         */
        keepDexApply = false

        /**
         * optional, default 'false'
         * Whether tinker should treat the base apk as the one being protected by app
         * protection tools.
         * If this attribute is true, the generated patch package will contain a
         * dex including all changed classes instead of any dexdiff patch-info files.
         */
        isProtectedApp = false
    }
    lib {
        pattern = ["lib/*/*.so"]
    }

    res {
        pattern = ["res/*", "r/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]
        ignoreChange = []
        largeModSize = 100
    }

    packageConfig {
    }
    sevenZip {
        zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
//        path = "/usr/local/bin/7za"
    }
    buildConfig {
        keepDexApply = false
    }
}

/**
 * 如果只想在Release中打开tinker，可以把tinkerEnable赋值为这个函数的return
 * @return 是否为release
 */
def isRelease() {
    Gradle gradle = getGradle()
    String tskReqStr = gradle.getStartParameter().getTaskRequests().toString()

    Pattern pattern;
    if (tskReqStr.contains("assemble")) {
        println tskReqStr
        pattern = Pattern.compile("assemble(\\w*)(Release|Debug)")
    } else {
        pattern = Pattern.compile("generate(\\w*)(Release|Debug)")
    }
    Matcher matcher = pattern.matcher(tskReqStr)

    if (matcher.find()) {
        String task = matcher.group(0).toLowerCase()
        println("[BuildType] Current task: " + task)
        return task.contains("release")
    } else {
        println "[BuildType] NO MATCH FOUND"
        return true;
    }
}